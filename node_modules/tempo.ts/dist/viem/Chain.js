import * as Hex from 'ox/Hex';
import { TokenId } from 'ox/tempo';
import { defineTransaction, defineTransactionReceipt, defineTransactionRequest, } from 'viem';
import * as Formatters from './Formatters.js';
import * as Transaction from './Transaction.js';
function config(chain) {
    const nonceKeyManager = {
        counter: 0,
        resetScheduled: false,
        reset() {
            this.counter = 0;
            this.resetScheduled = false;
        },
        get() {
            if (!this.resetScheduled) {
                this.resetScheduled = true;
                queueMicrotask(() => this.reset());
            }
            const count = this.counter;
            this.counter++;
            if (count === 0)
                return 0n;
            return Hex.toBigInt(Hex.random(6));
        },
    };
    return {
        blockTime: 1_000,
        formatters: {
            transaction: defineTransaction({
                exclude: ['aaAuthorizationList'],
                format: Formatters.formatTransaction,
            }),
            transactionReceipt: defineTransactionReceipt({
                format: Formatters.formatTransactionReceipt,
            }),
            transactionRequest: defineTransactionRequest({
                format: (...[request, action]) => Formatters.formatTransactionRequest({
                    ...request,
                    // Note: if we have marked the transaction as intended to be paid
                    // by a fee payer (feePayer: true), we will not infer the fee token
                    // as the fee payer will choose their fee token.
                    ...(request.feePayer !== true &&
                        (action === 'estimateGas' ||
                            action === 'fillTransaction' ||
                            action === 'sendTransaction')
                        ? {
                            feeToken: request.feeToken ?? chain.feeToken,
                        }
                        : {}),
                }, action),
            }),
        },
        async prepareTransactionRequest(r) {
            const request = r;
            const nonceKey = (() => {
                if (typeof request.nonceKey !== 'undefined')
                    return request.nonceKey;
                const nonceKey = nonceKeyManager.get();
                if (nonceKey === 0n)
                    return undefined;
                return nonceKey;
            })();
            const nonce = (() => {
                if (typeof request.nonce === 'number')
                    return request.nonce;
                // TODO: remove this line once `eth_fillTransaction` supports nonce keys.
                if (nonceKey)
                    return 0;
                return undefined;
            })();
            return { ...request, nonce, nonceKey };
        },
        serializers: {
            // TODO: casting to satisfy viem â€“ viem v3 to have more flexible serializer type.
            transaction: ((transaction, signature) => Transaction.serialize({
                ...transaction,
                // If we have marked the transaction as intended to be paid
                // by a fee payer (feePayer: true), we will not infer the fee token
                // as the fee payer will choose their fee token.
                ...(transaction.feePayer !== true
                    ? {
                        feeToken: transaction.feeToken ??
                            chain.feeToken ??
                            undefined,
                    }
                    : {}),
            }, signature)),
        },
        ...chain,
    };
}
export function define(chain) {
    return Object.assign((properties = {}) => config({ ...chain, ...properties }), { id: chain.id });
}
export { TokenId };
//# sourceMappingURL=Chain.js.map