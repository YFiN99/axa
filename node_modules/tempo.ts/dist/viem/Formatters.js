// TODO: Find opportunities to make this file less duplicated + more simplified with Viem v3.
import * as Hex from 'ox/Hex';
import { Transaction as ox_Transaction, TransactionRequest as ox_TransactionRequest, } from 'ox/tempo';
import { formatTransaction as viem_formatTransaction, formatTransactionReceipt as viem_formatTransactionReceipt, formatTransactionRequest as viem_formatTransactionRequest, } from 'viem';
import { parseAccount } from 'viem/accounts';
import { isTempo, } from './Transaction.js';
export function formatTransaction(transaction) {
    if (!isTempo(transaction))
        return viem_formatTransaction(transaction);
    const { feePayerSignature, gasPrice: _, nonce, ...tx } = ox_Transaction.fromRpc(transaction);
    return {
        ...tx,
        accessList: tx.accessList,
        feePayerSignature: feePayerSignature
            ? {
                r: Hex.fromNumber(feePayerSignature.r, { size: 32 }),
                s: Hex.fromNumber(feePayerSignature.s, { size: 32 }),
                v: BigInt(feePayerSignature.v ?? 27),
                yParity: feePayerSignature.yParity,
            }
            : undefined,
        nonce: Number(nonce),
        typeHex: ox_Transaction.toRpcType[tx.type],
        type: tx.type,
    };
}
export function formatTransactionReceipt(receipt) {
    return viem_formatTransactionReceipt(receipt);
}
export function formatTransactionRequest(r, action) {
    const request = r;
    const account = request.account
        ? parseAccount(request.account)
        : undefined;
    // Convert EIP-1559 transactions to Tempo transactions.
    if (request.type === 'eip1559')
        request.type = 'tempo';
    // If the request is not a Tempo transaction, route to Viem formatter.
    if (!isTempo(request))
        return viem_formatTransactionRequest(r, action);
    if (action)
        request.calls = request.calls ?? [
            {
                to: r.to ||
                    (!r.data || r.data === '0x'
                        ? '0x0000000000000000000000000000000000000000'
                        : undefined),
                value: r.value,
                data: r.data,
            },
        ];
    const rpc = ox_TransactionRequest.toRpc({
        ...request,
        type: 'tempo',
    });
    if (action === 'estimateGas') {
        rpc.maxFeePerGas = undefined;
        rpc.maxPriorityFeePerGas = undefined;
    }
    // JSON-RPC accounts (wallets) don't support Tempo transactions yet,
    // we will omit the type to attempt to make them compatible
    // with the base transaction structure.
    // TODO: `calls` will not be supported by a lot of JSON-RPC accounts (wallet),
    // use `wallet_sendCalls` or sequential `eth_sendTransaction` to mimic the
    // behavior of `calls`.
    if (account?.type === 'json-rpc') {
        if (rpc.calls?.length && rpc.calls.length > 1)
            throw new Error('Batch calls are not supported with JSON-RPC accounts yet.');
        rpc.type = undefined;
    }
    // We rely on `calls` for Tempo transactions.
    // However, `calls` may not be supported by JSON-RPC accounts (wallets) yet,
    // so we will not remove the `data`, `to`, and `value` fields to make it
    // compatible with the base transaction structure.
    if (account?.type !== 'json-rpc') {
        rpc.to = undefined;
        rpc.data = undefined;
        rpc.value = undefined;
    }
    const [keyType, keyData] = (() => {
        const type = account && 'keyType' in account ? account.keyType : account?.source;
        if (!type)
            return [undefined, undefined];
        if (type === 'webAuthn')
            // TODO: derive correct bytes size of key data based on webauthn create metadata.
            return ['webAuthn', `0x${'ff'.repeat(1400)}`];
        if (['p256', 'secp256k1'].includes(type))
            return [type, undefined];
        return [undefined, undefined];
    })();
    return {
        ...rpc,
        ...(keyType ? { keyType } : {}),
        ...(keyData ? { keyData } : {}),
        ...(request.feePayer
            ? {
                feePayer: typeof request.feePayer === 'object'
                    ? parseAccount(request.feePayer)
                    : request.feePayer,
            }
            : {}),
    };
}
//# sourceMappingURL=Formatters.js.map